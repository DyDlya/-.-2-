3.1 Общее определение и информация о жадных алгоритмах
Жадный алгоритм - алгоритм, заключающийся в принятии локально оптимальных решений на каждом этапе, допуская, что конечное решение также окажется оптимальным. 
Говорят, что к оптимизационной задаче применим принцип жадного выбора, если последовательность локально оптимальных выборов даёт глобально оптимальное решение. В типичном случае доказательство оп-тимальности следует такой схеме:
 1.Доказывается, что жадный выбор на первом шаге не закрывает пу-ти к оптимальному решению: для всякого решения есть другое, согласо-ванное с жадным выбором и не хуже первого.
 2.Показывается, что подзадача, возникающая после жадного выбора на первом шаге, аналогична исходной.
 3.Рассуждение завершается по индукции.
Говорят, что задача обладает свойством оптимальности для подза-дач для выведения результата, если оптимальное решение задачи содер-жит в себе оптимальные решения для всех её подзадач.
Особенностями жадных алгоритмов являются:
 1.Простота разработки;
 2.Простота анализа времени выполнения;
 3.Сложность в установлении правильности выполнения.
Одна из причин труднодоказуемости правильности жадных алго-ритмов — в том, что большинство таких алгоритмов на самом деле не яв-ляются правильными. Существуют наборы входных данных, на которых алгоритм будет выдавать неправильный результат. Поэтому необходимо тщательно проверять реализацию и следить за каждый шагом выполнения.

3.2 Элементы жадной стратегии
Жадный алгоритм позволяет получить оптимальное решение задачи путем осуществления ряда выборов. В каждой точке принятия решения в алгоритме делается выбор, который в данный момент выглядит самым лучшим. Эта эвристическая стратегия не всегда дает оптимальное решение, но все же решение может оказаться и оптимальным
Процесс разработки жадного алгоритма заключается в прохождении следующих этапов:
 1.Определение оптимальной подструктуры задачи;
 2.Разработка рекурсивного решения;
 3.Доказать, что на любом этапе рекурсии один из оптимальных вы-боров является жадным. Из этого будет следует, что всегда можно делать жадный выбор;
 4.Показать, что все возникающие в результате жадного выбора под-задачи, кроме одной, — пустые;
 5.Разработать рекурсивный алгоритм, реализующий жадную стра-тегию;
 6.Рекурсивный алгоритм преобразовать в итеративный;
Общего критерия оценки применимости жадного алгоритма для ре-шения конкретной задачи не существует, однако для задач, решаемых жадными алгоритмами, характерны две особенности: во-первых, к ним применим принцип жадного выбора, а во-вторых, они обладают свой-ством оптимальности для подзадач.

3.2.1 Свойство жадного выбора
Данное свойство заключается в следующем: глобальное оптимальное решение можно получить, делая локальный оптимальный (жадный) выбор. 
Рассмотрим отличие жадных алгоритмов от динамического про-граммирования. В динамическом программировании на каждом этапе де-лается выбор, однако обычно этот выбор зависит от решений подзадач. Следовательно, методом динамического программирования задачи обыч-но решаются в восходящем направлении, т.е. сначала обрабатываются бо-лее простые подзадачи, а затем — более сложные. В жадном алгоритме делается выбор, который выглядит в данный момент наилучшим, после чего решается подзадача, возникающая в результате этого выбора. Вы-бор, сделанный в жадном алгоритме, может зависеть от сделанных ранее выборов, но он не может зависеть от каких бы то ни было выборов или решений последующих подзадач. Таким образом, в отличие от динамиче-ского программирования, где подзадачи решаются в восходящем порядке, жадная стратегия обычно разворачивается в нисходящем порядке, когда жадный выбор делается один за другим, в результате чего каждый экзем-пляр текущей задачи сводится к более простому.
Свойство жадного выбора часто дает определенное преимущество, позволяющее повысить эффективность выбора в подзадаче. Зачастую ока-зывается, что благодаря предварительной обработке входных данных или применению подходящей структуры данных (нередко это очередь с прио-ритетами) можно ускорить процесс жадного выбора, что приведет к по-вышению эффективности алгоритма.

3.2.2 Оптимальная подструктура
Оптимальная подструктура проявляется в задаче, если в ее опти-мальном решении содержатся оптимальные решения подзадач. Это свой-ство является основным признаком применимости как динамического про-граммирования, так и жадных алгоритмов. Его суть, для задачи распреде-ления процесса, заключается в следующем: если оптимальное решение подзадачи Sij содержит процесс ak, то оно также содержит оптимальные решение подзадач Sik и Skj . После выявления этой оптимальной подструк-туры было показано, что если известно, какой процесс используется в ка-честве процесса ak, то оптимальное решение задачи Sij можно построить путем выбора процесса ak и объединения его со всеми процессами в опти-мальных решениях подзадач Sik и Skj.
Обычно при работе с жадными алгоритмами применяется более про-стой подход.
Для получения результата остаётся только обосновать, что опти-мальное решение подзадачи в сочетании с ранее сделанным жадным вы-бором провидит к оптимальному решению исходной задачи. В этой схеме для доказательства того, что жадный выбор на каждом шаге приводит к оптимальному решению, неявно используется индукция по вспомогатель-ным задачам.

3.3 Применение жадных алгоритмов
3.3.1 Решение задачи о размене монет
Формулировка задачи, следующая: монетная система некоторого государства состоит из монет достоинством а1 = 1 < a2 < … < an. Требуется выдать сумму S наименьшим возможным количеством монет.
Жадный алгоритм решения этой задачи таков. Берётся наибольшее возможное количество монет достоинства an : xn = S/an. Таким же образом получаем, сколько нужно монет меньшего номинала.
Для данной задачи жадный алгоритм не всегда даёт оптимальное решение, а только для некоторых, называемых каноническими, монетных систем, вроде используемых в США (1, 5, 10, 25 центов). Неканонические системы таким свойством не обладают. 

3.3.2 Алгоритм Дейкстры
Алгоритм находит кратчайшие пути от одной из вершин графа до всех остальных. Его суть заключается в следующем: каждой вершине из V сопоставим метку — минимальное известное расстояние от этой вершины до a. Алгоритм работает пошагово — на каждом шаге он «посещает» одну вершину и пытается уменьшать метки. Если все вершины посещены, алго-ритм завершается. В противном случае, из ещё не посещённых вершин выбирается вершина u, имеющая минимальную метку. Рассматриваются всевозможные маршруты, в которых u является предпоследним пунктом. Вершины, в которые ведут рёбра из u, назовём соседями этой вершины. Для каждого соседа вершины u, кроме отмеченных как посещённые, рас-смотрим новую длину пути, равную сумме значений текущей метки u и длины ребра, соединяющего u с этим соседом. Если полученное значение длины меньше значения метки соседа, заменим значение метки получен-ным значением длины. Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.

3.3.3 Алгоритм Прима
Предназначен для нахождения минимального остового дерева. По-следовательность действий при выполнении алгоритма следующая. На вход алгоритма подаётся связный неориентированный граф. Для каждого ребра задаётся его стоимость.
Сначала берётся произвольная вершина и находится ребро, инци-дентное данной вершине и обладающее наименьшей стоимостью. Найден-ное ребро и соединяемые им две вершины образуют дерево. Затем, рас-сматриваются рёбра графа, один конец которых — уже принадлежащая дереву вершина, а другой — нет; из этих рёбер выбирается ребро наименьшей стоимости. Выбираемое на каждом шаге ребро присоединяет-ся к дереву. Рост дерева происходит до тех пор, пока не будут исчерпаны все вершины исходного графа. 
Результатом работы алгоритма является остовное дерево минималь-ной стоимости.
